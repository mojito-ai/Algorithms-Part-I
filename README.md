# Algorithms-Part-I
![Algorithms-Part-I](https://s3.amazonaws.com/coursera_assets/meta_images/generated/XDP/XDP~COURSE!~algorithms-part1/XDP~COURSE!~algorithms-part1.jpeg)

An ensemble of Data Structures &amp; Algorithms used in computational science. Designed in accordance with Princeton University MOOC (Coursera) &amp; programmed in Java.

[Link to the course](https://online.princeton.edu/node/201)

The git-repo includes algorithms used widely in computational science, computational biology and in all IT sectors. The algorithms are divided into the following categories:

1. #### **Union Find**: Basic approach to developing and analyzing algorithms by considering the dynamic connectivity problem. We introduce the union–find data type and consider several implementations (quick find, quick union, weighted quick union, and weighted quick union with path compression). Finally, we apply the union–find data type to the percolation problem from physical chemistry.

2. #### **Analysis of Algorithms**: The basis of our approach for analyzing the performance of algorithms is the scientific method. We begin by performing computational experiments to measure the running times of our programs. We use these measurements to develop hypotheses about performance. Next, we create mathematical models to explain their behavior. Finally, we consider analyzing the memory usage of our Java programs.

3. #### **Stacks and Queues**: We consider two fundamental data types for storing collections of objects: the stack and the queue. We implement each using either a singly-linked list or a resizing array. We introduce two advanced Java features—generics and iterators—that simplify client code. Finally, we consider various applications of stacks and queues ranging from parsing arithmetic expressions to simulating queueing systems.

4. #### **Elementary Sorts**: We introduce the sorting problem and Java's Comparable interface. We study two elementary sorting methods (selection sort andinsertion sort) and a variation of one of them (shellsort). We also consider two algorithms for uniformly shuffling an array. We conclude with an application of sorting to computing the convex hull via the Graham scan algorithm.

5. #### **Merge Sort**
6. #### **Quick Sort**
7. #### **Priority Queues**
8. #### **Elementary Symbol Tables**
9. #### **Balanced Search Trees**
10. #### **Geometric Applications of BSTs**
11. #### **Hash Tables**
12. #### **Symbol Table Applications**

* **Author: Mohit Sharma**
* **Email: msharma3@me.iitr.ac.in**

Proper care has been taken to ensure that the speed analysis and the space analysis is done. There is a classic space/time tradeoff and the author has ensured to ensure fast processing algorithms in accordance with Moore's Law. Still there might be several errors or performance bugs at some places. Users are welcomed to create PR's or fork the repository to create better performing algorithms.

> An algorithm must be seen to be believed. - Sir Donald Knuth

>For me, great algorithms are the poetry of computation. Just like verse, they can be terse, allusive, dense, and even mysterious. But once unlocked, they cast a brilliant new light on some aspect of computing. - Francis Sullivan
